package bitvectors;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class Permutations {

	public static Cell firstVariant(Cell cell) {
		//number of the ports
		int rank = cell.getNumPorts();
		Cell pe = somePHDVariant(rank, cell);
		
		return null;
	}

	/**
	 * Cell must be centered
	 * Permutes cell to become port Hist Descending PHD
	 * destroys cell but returns new one to replace it
	 * @param rank
	 * @param cell
	 * @return
	 */
	private static Cell somePHDVariant(int rank, Cell cell) {
		int[] hh = new int[10];
		Cell pe = below(rank); 
		Cell pg = null;
		Histogram.rank = rank;
		Histogram.portHisto(cell, hh);
		
		//sort hh and pe
		//check this...
		Arrays.sort(hh);
		pe.sortBySize();
		
		BitVector[] pgBV = new BitVector[pe.size()];
		int p = 1;
		for(int i = 0; i < rank; i++){
			int num = pe.getPortAssignments()[i].getNumber();
			pgBV[ pe.getPortAssignments()[i].getNumber() ] = new BitVector(p);
			p <<= 1;
		}
		pe = permuteCell(cell, pg);
		
		
		return null;
	}
	
	/**
	 * Must be a permutation of powers of 2
	 * returns the port permutation of inputted cell
	 */
	private static Cell permuteCell(Cell cell, Cell permutation){
		Set<BitVector> result = new HashSet<BitVector>();
		
		for(int i = 0; i < cell.size(); i++){
			BitVector current = cell.getPortAssignments()[i];
			int x = current.getNumber();
			int y = 0;
			int j = 0;
			while ( x > 0 ){
				BitVector perm = permutation.getPortAssignments()[j];
				y += ( x % 2 ) * perm.getNumber();
				x /= 2;
				j++;
			}
			result.add(new BitVector(y));
		}
		Cell answer = new Cell(result, 0);
		//check this
		answer.sortBySize();
		
		return answer;
	}
	
	/**
	 * makes a cell with bitvectors 0 - n-1
	 * @param n
	 * @return
	 */
	private static Cell below(int n){
		Set<BitVector> set = new HashSet<BitVector>();
		for(int i = 0; i < n; i++){
			set.add(new BitVector(i));
		}
		return new Cell(set, 0);
	}

}
