package bitvectors;

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Cell {
	/**
	 * Number of ports in the cell
	 */
	private int numPorts;
	/**
	 * Set of bitvectors, each representing a port assignment of this cell
	 */
	private ArrayList<BitVector> portAssignments;

	/**
	 * 
	 */
	private boolean centered;
	
	/**
	 *  
	 * @param a
	 * @param b
	 * @return
	 */
	public static Cell union(Cell a, Cell b){
		Set<BitVector> union = new HashSet<BitVector>();
		union.addAll(a.portAssignments);
		union.addAll(b.portAssignments);
		return new Cell(union);
	}
	
	public Cell(){
		this.portAssignments = new HashSet<BitVector>();
		this.numPorts = 0;
		this.centered = false;
	}
	
	public Cell(Set<BitVector> portsAssigns){
		this.portAssignments = portsAssigns;
		this.numPorts = 0;
		this.centered = false;
	}
	
	public Cell(Cell c){
		this.portAssignments = c.portAssignments;
		this.numPorts = c.numPorts;
		this.centered = c.centered;
	}
	
	/**
	 * sorts this cell
	 */
	public void weightedSort(){
		//11 is rank limit
		//move to static variable
		int[] we = new int[11];
		//port assignments in array
		BitVector[] pA = null;
		if(this.sortedPAs == null){
			pA = this.portAssignments.toArray(new BitVector[1]);
		} else{
			pA = this.sortedPAs;
		}
		int x;
		
		for(int i = 0; i < this.size(); i++){
			x = pA[i].countBits() - 1;
			for(int p = 0; p < this.numPorts; p++){
				if( ( ( pA[i].getNumber() >> p) &  1 ) != 0){
					we[p] += x;
				}
			}
		}
		
		for(int i = 0; i < this.size(); i++){
			x = pA[i].getNumber();
			pA[i] = new BitVector(0);
			for(int p = 0; p < this.numPorts; p++){
				if( ( (x >> p) & 1) != 0){
					pA[i] = new BitVector( pA[i].getNumber() + we[p] );
				}
			}
			
		}
		
		Arrays.sort(pA, new Comparator<BitVector>(){
			@Override
			public int compare(BitVector o1, BitVector o2) {
				if(o1.getNumber() < o2.getNumber()){
					return -1;
				}
				else if(o1.getNumber() > o2.getNumber()){
					return 1;
				}
				return 0;
			}
		});
		
		this.setSortedPA(pA);
	}
	
	/**
	 * Translates a cell over port assignment 
	 * @param portAssignment
	 */
	public void translate(BitVector translation){
		//if nothing to translate
		if(translation.isEmpty()){
			return;
		}
		//new set of translated port assignments
		Set<BitVector> translated = new HashSet<BitVector>();
		
		//iterate over all cells current port assignments
		Iterator i = this.portAssignments.iterator();
		while(i.hasNext()){
			//grab current port assignment
			BitVector portAssignment = (BitVector) i.next();
			//get symmetric difference of current and translation
			BitVector symD = BitVector.symmetricDifference(
					portAssignment,
					translation);
			//place intersection in new port assignment set
			translated.add(symD);
		}
		
		this.portAssignments = translated;
	}
	
	/**
	 * Translate cell so it is centered
	 * @return
	 */
	public int center(){
		this.centered = true; 
		
		int k = 0;
		BitVector[] thisArray = this.portAssignments.toArray(new BitVector[1]);
		
		Cell wl = new Cell(this);
		wl.translate(thisArray[0]);
		wl.weightedSort();
		
		for(int i = 1; i < thisArray.length; i++){
			Cell owl = new Cell(this);
			owl.translate(thisArray[i]);
			owl.weightedSort();
			
			if( compareL(owl, wl) < 0 ){
				k = i;
				wl = owl;
			}
			else{
				owl = null;
			}
		}
		
		wl = null;
		int portAssignment = thisArray[k].getNumber();
		this.setSortedPA(thisArray);
		this.translate(thisArray[k]);
		return portAssignment;
	}
	
	public int compareL(Cell one, Cell two){
		
		int diff = one.sortedPAs.length - two.sortedPAs.length;
		if(diff == 0){
			return compareLex(diff, one, two);
		}
		return diff;
	}
	
	public int compareLex(int diff, Cell one, Cell two){
		BitVector[] first = one.sortedPAs;
		BitVector[] second = two.sortedPAs;
		diff--;
		while(diff >= 0 && first[diff] == second[diff]){
			diff--;
		}
		if(diff < 0){
			return 0;
		}
		return first[diff].getNumber() - second[diff].getNumber();
	}
	
	public String toString() {
		String[] portAssigns = new String[this.size()];
		int index = 0;
		int[] bitVectors = new int[this.size()];
		String answer = "";
		
		if (!centered) {
			Iterator<BitVector> i = this.portAssignments.iterator();
			while (i.hasNext()) {
				bitVectors[index++] = ((BitVector) i.next()).getNumber();
			}
			answer = "Unweighted Cell: ";
		} 
		else {
			for (BitVector bv : this.sortedPAs) {
				bitVectors[index++] = bv.getNumber();
			}
			answer = "Cell: ";
		}
		Arrays.sort(bitVectors);
		index = 0;

		for (int number : bitVectors) {
			if (number == 0) {
				portAssigns[index] = "0";
				index++;
			} else {
				String ports = "";
				for (int j = this.numPorts; j > 0; j--) {
					if ((number & (1 << (j - 1))) != 0) {
						ports += (char) ('a' + j - 1);
					}
				}
				ports = Utils.sort(ports);
				portAssigns[index] = ports;
				index++;
			}
		}

		for (int k = 0; k < portAssigns.length; k++) {
			answer += portAssigns[k] + " ";
		}
		return answer;

	}

	public int size(){
		return this.portAssignments.size();
	}
	
	public void add(BitVector bv){
		this.portAssignments.add(bv);
	}
	
	public void clear(){
		this.portAssignments.clear();
	}

	public int getNumPorts() {
		return numPorts;
	}

	public void setNumPorts(int numPorts) {
		this.numPorts = numPorts;
	}
	
	public void setSortedPA(BitVector[] ba){
		this.sortedPAs = ba;
		Set<BitVector> ss = new HashSet<BitVector>();
		for(BitVector bv: this.sortedPAs){
			ss.add(bv);
		}
		this.portAssignments = ss;
	}
	
	
}
