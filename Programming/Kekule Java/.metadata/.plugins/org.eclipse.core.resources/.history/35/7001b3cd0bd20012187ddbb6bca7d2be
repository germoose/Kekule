package bitvectors;

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Cell {
	/**
	 * Number of ports in the cell
	 */
	private int numPorts;
	/**
	 * Set of bitvectors, each representing a port assignment of this cell
	 */
	private BitVector[] portAssignments;

	/**
	 * 
	 */
	private boolean centered;
	
	/**
	 *  
	 * @param a
	 * @param b
	 * @return
	 */
	public static Cell union(Cell a, Cell b){
		Set<BitVector> union = new HashSet<BitVector>();
		//union.addAll(a.portAssignments);
		//union.addAll(b.portAssignments);
		return new Cell(union);
	}
	
	public Cell(){
		this.portAssignments = null;
		this.numPorts = 0;
		this.centered = false;
	}
	
	public Cell(BitVector[] portsA){
		this.portAssignments = portsA;
		this.numPorts = 0;
		this.centered = false;
	}
	
	public Cell(Cell c){
		this.portAssignments = c.portAssignments;
		this.numPorts = c.numPorts;
		this.centered = c.centered;
	}
	
	/**
	 * sorts this cell
	 */
	public void weightedSort(){
		//11 is rank limit
		//move to static variable
		int[] we = new int[11];
		//port assignments in array
		int x;
		
		for(int i = 0; i < this.size(); i++){
			x = this.portAssignments[i].countBits() - 1;
			for(int p = 0; p < this.numPorts; p++){
				if( ( ( this.portAssignments[i].getNumber() >> p) &  1 ) != 0){
					we[p] += x;
				}
			}
		}
		
		for(int i = 0; i < this.size(); i++){
			x = this.portAssignments[i].getNumber();
			this.portAssignments[i] = new BitVector(0);
			for(int p = 0; p < this.numPorts; p++){
				if( ( (x >> p) & 1) != 0){
					this.portAssignments[i] = new BitVector( this.portAssignments[i].getNumber() + we[p] );
				}
			}
			
		}
		
		Arrays.sort(this.portAssignments, new Comparator<BitVector>(){
			@Override
			public int compare(BitVector o1, BitVector o2) {
				if(o1.getNumber() < o2.getNumber()){
					return -1;
				}
				else if(o1.getNumber() > o2.getNumber()){
					return 1;
				}
				return 0;
			}
		});
		
		this.setSortedPA(this.portAssignments);
	}
	
	/**
	 * Translates a cell over port assignment 
	 * @param portAssignment
	 */
	public void translate(BitVector translation){
		//if nothing to translate
		if(translation.isEmpty()){
			return;
		}
		//new set of translated port assignments
		BitVector[] translated = new BitVector[this.size()];
		
		//iterate over all cells current port assignments
		for(int i = 0; i < this.size(); i++){
			BitVector bv = this.portAssignments[i];
			//get symmetric difference of current and translation
			BitVector symD = BitVector.symmetricDifference(
					bv,
					translation);
			//place intersection in new port assignment set
			translated[i] = symD;
		}
		
		this.portAssignments = translated;
	}
	
	/**
	 * Translate cell so it is centered
	 * @return
	 */
	public int center(){
		this.centered = true; 
		
		int k = 0;
		
		Cell wl = new Cell(this);
		wl.translate(this.portAssignments[0]);
		wl.weightedSort();
		
		for(int i = 1; i < this.portAssignments.length; i++){
			Cell owl = new Cell(this);
			owl.translate(this.portAssignments[i]);
			owl.weightedSort();
			
			if( compareL(owl, wl) < 0 ){
				k = i;
				wl = owl;
			}
			else{
				owl = null;
			}
		}
		
		wl = null;
		int portAssignment = this.portAssignments[k].getNumber();
		this.setSortedPA(this.portAssignments);
		this.translate(this.portAssignments[k]);
		return portAssignment;
	}
	
	public int compareL(Cell one, Cell two){
		
		int diff = one.sortedPAs.length - two.sortedPAs.length;
		if(diff == 0){
			return compareLex(diff, one, two);
		}
		return diff;
	}
	
	public int compareLex(int diff, Cell one, Cell two){
		BitVector[] first = one.sortedPAs;
		BitVector[] second = two.sortedPAs;
		diff--;
		while(diff >= 0 && first[diff] == second[diff]){
			diff--;
		}
		if(diff < 0){
			return 0;
		}
		return first[diff].getNumber() - second[diff].getNumber();
	}
	
	public String toString() {
		String[] portAssigns = new String[this.size()];
		int index = 0;
		int[] bitVectors = new int[this.size()];
		String answer = "";
		
		if (!centered) {
			Iterator<BitVector> i = this.portAssignments.iterator();
			while (i.hasNext()) {
				bitVectors[index++] = ((BitVector) i.next()).getNumber();
			}
			answer = "Unweighted Cell: ";
		} 
		else {
			for (BitVector bv : this.sortedPAs) {
				bitVectors[index++] = bv.getNumber();
			}
			answer = "Cell: ";
		}
		Arrays.sort(bitVectors);
		index = 0;

		for (int number : bitVectors) {
			if (number == 0) {
				portAssigns[index] = "0";
				index++;
			} else {
				String ports = "";
				for (int j = this.numPorts; j > 0; j--) {
					if ((number & (1 << (j - 1))) != 0) {
						ports += (char) ('a' + j - 1);
					}
				}
				ports = Utils.sort(ports);
				portAssigns[index] = ports;
				index++;
			}
		}

		for (int k = 0; k < portAssigns.length; k++) {
			answer += portAssigns[k] + " ";
		}
		return answer;

	}

	public int size(){
		return this.portAssignments.size();
	}
	
	public void add(BitVector bv){
		this.portAssignments.add(bv);
	}
	
	public void clear(){
		this.portAssignments.clear();
	}

	public int getNumPorts() {
		return numPorts;
	}

	public void setNumPorts(int numPorts) {
		this.numPorts = numPorts;
	}
}
